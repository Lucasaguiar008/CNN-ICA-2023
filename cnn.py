# -*- coding: utf-8 -*-
"""CNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oBY7rCPL2xtKYS1fG2BFH7GOTFZWg9hM
"""

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras import datasets, layers, models

# Carregando os dados de treino e teste do dataset
(x_train, y_train), (x_test, y_test) = datasets.cifar10.load_data()

#Etapa de normalização dos dados
x_train, x_test = x_train/255.0, x_test/255.0

plt.imshow(x_train[7])
plt.show()

learning_rate = 0.001 #taxa de aprendizado
dropout_1 = 0.25
dropout_2 = 0.25
dropout_3 = 0.25
batch_size = 500 #Faz a função do k-fold, como temos 50k amostras de treinamento, treina de 5k em 5k

model = models.Sequential()

# primeira camada
model.add(layers.Conv2D(64,(2,2), activation='relu',padding="same", input_shape = (32,32,3)))
model.add(layers.Conv2D(512, (3,3), activation='relu',padding="same"))
model.add(layers.MaxPooling2D((2,2)))
model.add(layers.Dropout(dropout_1))

# segunda camada
model.add(layers.Conv2D(512,(3,3), activation='relu',padding="same"))
model.add(layers.Conv2D(512, (3,3), activation='relu',padding="same"))
model.add(layers.MaxPooling2D((2,2)))
model.add(layers.Dropout(dropout_2))

# terceira camada
model.add(layers.Conv2D(512, (3,3), activation='relu',padding="same"))
model.add(layers.Conv2D(512, (3,3), activation='relu',padding="same"))
model.add(layers.MaxPooling2D((2,2)))
model.add(layers.Dropout(dropout_3))


model.add(layers.Flatten())
model.add(layers.Dense(1024, activation='relu'))
model.add(layers.Dense(512, activation='relu'))
model.add(layers.Dense(10, activation='softmax')) #camada de saída, 10 neurônios


optimizer = tf.optimizers.Adam(learning_rate=learning_rate)

model.compile(optimizer=optimizer,
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

epochs = 150
history = model.fit(x_train, y_train, batch_size=batch_size,epochs=epochs,
                    validation_data=(x_test, y_test))

# Plotar a acurácia e a acurácia de validação
plt.plot(history.history['accuracy'], label='Acurácia Treinamento')
plt.plot(history.history['val_accuracy'], label='Acurácia Teste')
plt.title('Acurácia da CNN')
plt.xlabel('Épocas')
plt.ylabel('Acurácia')
plt.legend()
#plt.show()

indice_max = np.argmax(history.history['accuracy'])
max_accuracy = history.history['accuracy'][indice_max]

indice_max = np.argmax(history.history['val_accuracy'])
max_val_accuracy = history.history['val_accuracy'][indice_max]

max_accuracy, max_val_accuracy

# Adicionar o valor máximo na legenda
plt.text(epochs-1, 0.4, f'Max. Acurácia Trein.: {100*max_accuracy:.2f}%', ha='right', va='center')
plt.text(epochs-1, 0.38, f'Max. Acurácia Teste: {100*max_val_accuracy:.2f}%', ha='right', va='center')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix

# Obter as previsões para os conjuntos de treinamento e teste
train_predictions = model.predict(x_train)
test_predictions = model.predict(x_test)

# Converter as previsões em rótulos de classe
train_predicted_labels = np.argmax(train_predictions, axis=1)
test_predicted_labels = np.argmax(test_predictions, axis=1)

# Calcular as matrizes de confusão
train_cm = confusion_matrix(y_train, train_predicted_labels)
test_cm = confusion_matrix(y_test, test_predicted_labels)

# Função auxiliar para plotar a matriz de confusão com porcentagens
def plot_confusion_matrix(cm, classes, title):
    cm_percent = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]  # Calcular porcentagens
    plt.imshow(cm_percent, interpolation='nearest', cmap=plt.cm.Blues)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)
    plt.xlabel('Rótulo predito')
    plt.ylabel('Rótulo verdadeiro')

    # Adicionar as porcentagens como anotações na matriz de confusão
    thresh = cm_percent.max() / 2.  # Limiar para exibir a cor do texto
    for i in range(cm_percent.shape[0]):
        for j in range(cm_percent.shape[1]):
            plt.text(j, i, format(cm_percent[i, j], '.2f'),
                     horizontalalignment="center",
                     color="white" if cm_percent[i, j] > thresh else "black")

    plt.show()

class_names = ('avião', 'carro', 'pássaro', 'gato', 'cervo',
           'cachorro', 'sapo', 'cavalo', 'barco', 'caminhão')

# Plotar a matriz de confusão do conjunto de treinamento com porcentagens
plot_confusion_matrix(train_cm, class_names, 'Matriz de confusão - Treinamento')

# Plotar a matriz de confusão do conjunto de teste com porcentagens
plot_confusion_matrix(test_cm, class_names, 'Matriz de confusão - Teste')